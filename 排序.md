# 排序

### 冒泡排序
基本思路：每次交换相邻两个元素，把较大值向后移，每轮循环的结果是将当前最大值移到最后。相应地，每轮结束后需要排序的数组长度递减。
```java
    public static void bubbleSort(Comparable[] a) {
        for(int i = 0; i < a.length; i ++) {
            for(int j = 0; j < a.length - 1 - i; j ++) {
                if(a[j].compareTo(a[j + 1]) > 0) {
                    exchange(a, j, j + 1);
                }
            }
        }
    }
```

### 选择排序
基本思路：在待排序数组中，假设首元素为最小值并记录该下标，遍历后面的元素，将其与当前最小值作比较。若遇到更小值，则将最小值下标标记为该元素。最后将最小值交换到首元素位置。因此每轮结束后待排序数组为首元素其后元素。
```java
    public static void selectionSort(Comparable[] a) {
        for(int i = 0; i < a.length; i ++) {
            int min = i;
            for(int j = i + 1; j < a.length; j ++) {
                if(a[j].compareTo(a[min]) < 0) {
                    min = j;
                }
            }
            if(i != min) {
                exchange(a, i, min);
            }
        }
    }
```

### 插入排序
基本思路：从第二个元素开始遍历，假设前方元素有序（一个元素时必然有序），将当前元素插入到有序序列中。将前方元素的较大值后移，直到找到当前元素的位置。
```java
    public static void insertionSort(Comparable[] a) {
        for(int i = 1; i < a.length; i ++) {
            Comparable x = a[i];
            int j = i - 1;
            while(j >= 0 && a[j].compareTo(x) > 0) {
                a[j + 1] = a[j];
                j --;
            }
            a[j + 1] = x;
        }
    }
```

### 希尔排序
基本思路：和插入排序思路类似，不同的是，插入的间隔从一个较大值一直收敛到1。理解的关键是，处于同一个间隔值的不同“平行”序列的排序是互不影响的。
```java
    public static void shellSort(Comparable[] a) {
        int len = a.length;
        int gap = 1;
        while(gap < len / 3) {
            gap = gap * 3 + 1;
        }// Knuth
        while(gap >= 1) {
            for(int i = gap; i < len; i ++) {
                int j = i - gap;
                Comparable x = a[i];
                while(j >= 0 && a[j].compareTo(x) > 0) {
                    a[j + gap] = a[j];
                    j -= gap;
                }
                a[j + gap] = x;
            }
            gap /= 3;
        }
    }
```

### 归并排序
基本思路：典型的分治思路，将待排序数组平均分成左右两部分，将左边进行排序，然后将右边进行排序，最后将左边和右边两个有序序列合并起来，得到一个有序的数组。基本点是只有两个元素时，左右都必然有序，只需将它们合并在一起即可。递归写法比较自然，循环的写法要注意控制数组间隔大小逐渐翻倍。
```java
    // 归并排序循环写法
    public static void mergeSortBU(Comparable[] a) {
        Comparable[] tmp = new Comparable[a.length];
        for(int step = 1; step < a.length; step += step) {
            for(int low = 0; low < a.length - step; low += step + step) {
                merge(a, low, low + step - 1,
                        Math.min(low + step + step - 1, a.length - 1), tmp);
            }
        }
    }
    
    // 归并排序递归写法
    public static void mergeSort(Comparable[] a) {
        Comparable[] tmp = new Comparable[a.length];
        mergeSortHelper(a, 0, a.length - 1, tmp);
    }
    
    private static void mergeSortHelper(Comparable[] a, int low, int high, Comparable[] tmp) {
        if(low >= high) return;
        int mid = (low + high) / 2;
        mergeSortHelper(a, low, mid, tmp);
        mergeSortHelper(a, mid + 1, high, tmp);
        if(a[mid].compareTo(a[mid + 1]) <= 0) return;
        merge(a, low, mid, high, tmp);
    }
    
    private static void merge(Comparable[] a, int low, int mid, int high, Comparable[] tmp) {
        for(int i = low; i <= high; i ++) {
            tmp[i] = a[i];
        }
        int i = low, j = mid + 1;
        for(int k = low; k <= high; k ++) {
            if(i > mid) {
                a[k] = tmp[j ++]; 
            } else if(j > high) {
                a[k] = tmp[i ++];
            } else if(tmp[i].compareTo(tmp[j]) < 0) {
                a[k] = tmp[i ++];
            } else {
                a[k] = tmp[j ++];
            }
        }
    }
```

### 快速排序
基本思路：把待排序数组的首元素作为切分元素，将数组切分为两部分，满足切分元素左边的所有元素不大于其值，右边的所有元素不小于其值。切分方法如下：
>1. 下标i从左往右扫描，找到第一个大于切分元素的元素；
>2. 下标j从右往左扫描，找到第一个小于切分元素的元素；
>3. 交换上述两个元素的位置；
>4. 重复以上步骤，直到i和j相遇交错，此时j右边的所有元素都不小于切分元素而j本身不大于切分元素，将j替换到首位即可。

有时候为了保证在平均情况下总能达到可靠的性能，会先将数组随机打乱再做快速排序。另外，在数据较小时，也可以使用插入排序来替换。为了简洁起见，代码中没有包含这两部分。

```java
    public static void quickSort(Comparable[] a) {
        quickSortHelper(a, 0, a.length - 1);
    }
    
    private static void quickSortHelper(Comparable[] a, int low, int high) {
        if(low >= high) return;
        int k = partition(a, low, high);
        quickSortHelper(a, low, k - 1);
        quickSortHelper(a, k + 1, high);
    }
    
    private static int partition(Comparable[] a, int low, int high) {
        int i = low + 1, j = high;
        while(true) {
            while(i <= high && a[i].compareTo(a[low]) < 0) {
                i ++;
            }
            while(j >= low && a[j].compareTo(a[low]) > 0) {
                j --;
            }
            if(i >= j) break;
            exchange(a, i, j);
        }
        exchange(a, low, j);
        return j;
    }
```

### 堆排序
基本思路：堆排序主要利用最大堆的性质，首先将数组元素构造成一个最大堆（自底向上不断将元素“下沉”），然后将首元素（最大值）与待排序数组最后一个元素交换，最后将交换上去的元素“沉下来”（可参考优先队列的思路，事实上就是优先队列）。
```java
    public static void heapSort(Comparable[] a) {
        int n = a.length - 1;
        for(int k = n / 2; k >= 1; k --) {
            sink(a, k, n);
        }
        while(n > 1) {
            exchange(a, 1, n);
            sink(a, 1, -- n);
        }
    }
    
    private static void sink(Comparable[] a, int k, int n) {
        while(k * 2 <= n) {
            int j = k * 2;
            if(j < n && a[j].compareTo(a[j + 1]) < 0) {
                j ++;
            }
            if(a[k].compareTo(a[j]) >= 0) break;
            exchange(a, k, j);
            k = j;
        }
    }
```
