# 查找

### 二分查找
在一个有序数组中，使用二分查找可以在O(logN)时间内得到结果。

**基本思路**：在一个有序数组中，要找到元素x的位置，每次将x与数组中间元素作比较，若x大于中间元素，则x可能存在于右半边数组；若x小于中间元素，则可能存在于左半边小组；否则中间元素就是x。不难看出，每一次的比较都会将需要搜索的范围减半，因此复杂度为O(logN)。

```java
    public static int rank(Comparable[] a, Comparable x) {
        int low = 0, high = a.length - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            int cmp = a[mid].compareTo(x);
            if(cmp < 0) {
                low = mid + 1;
            } else if(cmp > 0) {
                high = mid - 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
```

### 二叉查找树
二叉查找树是一棵有序的二叉树，其中所有元素满足（左子结点<=父结点<=右子结点）。

**查找**：在一棵二叉查找树中查找元素x，首先将x和根结点比较，若匹配则找到；若x大于根结点，则进入到右子树查找；若x小于根结点，则进入到左子树查找。重复操作，直到匹配或到达空结点。

**插入**：要构造一个二叉查找树，关键是构造其插入算法。插入的思路其实和查找很相似，首先找到相应的位置，要不覆盖原来的值，要不在空位置上添加一个新结点。

**删除**：删除操作稍微复杂。首先找到相应的位置，接下来分为下面几种情况：
>1. 若待删除结点x是叶子结点，则直接删除即可；
>2. 若待删除结点x是单子树结点，则跳过当前结点直接连接到该子树结点即可；
>3. 若该删除结点x是双子树结点，则首先需要找到右子树中的最左结点y（在不小于x中的最小值），然后将x替换为y的值，然后删除y（删除y的操作相对简单，因为它必然没有左子树）。

**最坏情况下无法保证O(logN)**：从上面可以看出，查找是核心操作，其性能影响整个数据结构的性能，而树的深度是决定查找效率的关键（每一次匹配进入一层）。在构建二叉查找树时，若元素是有序插入的，则二叉树会退化为链表，从而失去算法的优势。
![二叉查找树.png-11.8kB][1]

```java
package algorithm.search;

import edu.princeton.cs.algs4.Queue;

public class BinarySearchTree<Key extends Comparable<Key>, Value> {
    
    private class Node {
        private Key key;
        private Value value;
        private Node left, right;
        
        public Node(Key key, Value value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Node root;
    
    public void put(Key key, Value value) {
        root = this.put(root, key, value);
    }
    
    private Node put(Node node, Key key, Value value) {
        if(node == null) return new Node(key, value);
        
        int cmp = node.key.compareTo(key);
        if(cmp < 0) {
            node.right = put(node.right, key, value);
        } else if(cmp > 0) {
            node.left = put(node.left, key, value);
        } else {
            node.value = value;
        }
        return node;
    }
    
    public Value get(Key key) {
        Node node = root;
        while(node != null) {
            int cmp = node.key.compareTo(key);
            if(cmp < 0) {
                node = node.right;
            } else if(cmp > 0) {
                node = node.left;
            } else {
                return node.value;
            }
        }
        return null;
    }
    
    public void delete(Key key) {
        root = this.delete(root, key);
    }
    
    /**
     * 删除key元素
     * @param node
     * @param key
     * @return 删除key元素后的根节点
     */
    private Node delete(Node node, Key key) {
        if(node == null) return null;
        int cmp = node.key.compareTo(key);
        if(cmp < 0) {
            node.right = delete(node.right, key);
        } else if(cmp > 0) {
            node.left = delete(node.left, key);
        } else {
            if(node.left == null) return node.right;
            if(node.right == null) return node.left;
            
            Node origin = node;
            node = this.min(node.right);
            node.right = this.deleteMin(node.right);
            node.left = origin.left;
        }
        
        return node;
    }
    
    private Node min(Node node) {
        if(node.left == null) return node;
        return node.left;
    }
    
    /**
     * 删除树的最小值（最左边的元素）
     * @param node 非空根节点
     * @return 删除最小值后的根节点
     */
    private Node deleteMin(Node node) {
        if(node.left == null) return node.right;
        node.left = deleteMin(node.left);
        return node;
    }
    
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<>();
        inorder(queue, root);
        return queue;
    }
    
    private void inorder(Queue<Key> queue, Node node) {
        if(node == null) return;
        
        inorder(queue, node.left);
        queue.enqueue(node.key);
        inorder(queue, node.right);
    }

}
```

### 2-3树
2-3树可以保证在最坏情况下时间复杂度为O(logN)。2-3树的每个父结点要么有1个数据元素和2个孩子结点（2-Node），要么有2两个数据元素和3个孩子结点（3-Node）。叶子结点可以有1个数据元素（2-Node）或2个数据元素（3-Node）。

2-Node和普通的二叉查找树结点一样，3-Node多了一个特殊性质，处于中间的孩子结点大小必须在两个数据元素的值之间。具体如下所示：
![2-3树.png-10.7kB][2]

使用2-3树的主要原因在于，不论插入顺序如何，它都能在元素插入后保持平衡（所有空链接到根的距离误差在1内）。

**查找**：与二叉查找树类似，首先将x与根结点比较，然后进入相应的区间子树，递归遍历即可，这里不重复说明。

**插入**：插入的前期操作是查找，因此当我们定位到需要插入的位置后，有以下几种情况：
>1. 待插入位置是2-Node：直接插入元素使其称为一个3-Node；
![insert:2-Node][3]
>2. 待插入位置是3-Node且是根结点：创建一个临时的4-Node然后将其分解为3个2-Node的子树；
![insert: 3-Node.1][4]
>3. 待插入位置是3-Node且父结点是2-Node：和2类似，但这种情况下，4-Node分解后的子树的根结点会和原来的父结点2-Node合并为一个3-Node；
![insert: 3-Node.2][5]
>4. 待插入位置是3-Node且父结点是3-Node：和3类似，只是子树根结点和3-Node合并后又会称为一个临时的4-Node，重复继续向上弹出元素直至不存在4-Node。
![insert: 3-Node.3][6]

从插入操作可以看出2-3树的特性，与二叉查找树从顶向下生长不同，2-3树是自底向上生长的。只有当不得不向上生长一层的时候（出现一个4-Node），2-3树深度才会加1，而且这种生长是自适应的，3-Node的存在和4-Node的分解都是为了得到更平衡的树结构（打破像有序输入的链表状况）。

具体的实现代码后面再补，插入的思路就是首先定位到待插入位置，然后按照上述的情况处理，沿查找路径回溯逐渐适配树（递归写法很自然），类似思路可以参见红黑树。

### B树
2-3树可以看做B树的一个特例，B树的所有结点可以拥有M个数据元素和M+1个孩子结点。B树相应的操作和2-3树类似，只是会更为复杂一点。B树一般用在数据库和文件系统等需要和磁盘打交道的系统，由于B树的每个结点保存更多的元素，层数自然更少，因此可以减少磁盘IO访问的次数（每次访问一个层）。

### 红黑树
红黑树是一种“特殊的”二叉查找树，它可以保证在最坏情况下时间复杂度为O(logN)。可以这样理解，红黑树用一种特殊的标记模拟的2-3树的实现，使得其拥有插入自平衡的特性，拥有相对良好的效率。

红黑树是一棵带有颜色属性的二叉查找树，红链接将两个2-Node组成一个3-Node，黑链接则是普通链接。需要特别说的是，空链接默认是一个黑链接。具体性质如下：
>1. 红链接都是左链接；
>2. 没有任何一个结点同时和两条红链接相连；
>3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑连接数量相同。

**查找**：查找只需使用普通的二叉查找树算法即可，红黑树也是一棵二叉查找树。

**插入**：首先需要说明的是，我们每次插入一个新的结点默认它是一个与红链接相连的结点，类似于2-3树那构造临时的4-Node来向上生长（另类：根结点总是黑色的），然后利用旋转操作使得整棵树满足有序性和完美黑色平衡（每次旋转操作返回树的根结点。从下图可以看出，左旋转和右旋转并不会影响树的有序性，而是会使得其达到一种虚拟的4-Node状态，最后利用颜色翻转使得树向上生长。
![红黑树][7]
基本思路：首先使用查找算法定位到待插入位置，然后视条件依次进行旋转及颜色翻转操作，回溯查找路径重复步骤向上生长。在待插入位置有以下几种情况：
>1. 插入元素后，相邻的结点也是红链接，此时需要做颜色翻转，把根结点弹出到上层；
>2. 插入元素位于左子结点且相邻结点为黑链接，这种情况没有问题，需要再向上一层回溯；
>3. 插入元素位于右子结点且相邻结点为黑链接，这种情况下X需要做左旋转使其变为情况2。
>4. 在当前元素观察到下面两层左子结点都是红链接，这种情况需要做右旋转把这个虚拟的4-Node旋转到待弹出状态即情况1。

因此，在插入元素后（回溯上去接收下层弹出的根结点相当于插入一个元素），需要依次做下面适配：
>1. 若x的左子结点为黑链接，右子结点为红链接，则需要做左旋转；
>2. 若x下面的两层左子结点都为红链接，则需要做右旋转；
>3. 若x的左右子结点结尾结尾红链接，则需要做颜色翻转。

```java
package algorithm.search;

/**
 * 一种2-3树的变种，红链接相连的两个2节点等于一个3节点
 * @author yongd
 *
 * @param <Key>
 * @param <Value>
 */
public class RedBlackBST<Key extends Comparable<Key>, Value> {
    
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    
    private class Node {
        Key key;
        Value value;
        Node left, right;
        boolean color;      // color of parent link
        
        public Node(Key key, Value value, boolean color) {
            this.key = key;
            this.value = value;
            this.color = color;
        }
    }
    
    private boolean isRed(Node x) {
        if(x == null) {
            return false;
        } else {
            return x.color == RED;
        }
    }
    
    private Node root;
    
    public Value get(Key key) {
        Node x = root;
        while(x != null) {
            int cmp = x.key.compareTo(key);
            if(cmp < 0) {
                x = x.right;
            } else if(cmp > 0) {
                x = x.left;
            } else {
                return x.value;
            }
        }
        return null;
    }
    
    /**
     * 当右子节点是红色且左子节点是黑色时使用，将x左旋转下来
     * @param x
     * @return
     */
    private Node rotateLeft(Node x) {
        Node y = x.right;
        x.right = y.left;
        y.left = x;
        y.color = x.color;
        x.color = RED;
        return y;
    }
    
    /**
     * 当左子节点和其左子节点皆为红色时使用，将x右旋转下去
     * @param x
     * @return
     */
    private Node rotateRight(Node x) {
        Node y = x.left;
        x.left = y.right;
        y.right = x;
        y.color = x.color;
        x.color = RED;
        return y;
    }
    
    /**
     * 当左子节点和右子节点皆为红色时使用，变换颜色增加一层
     * @param x
     */
    private void flipColors(Node x) {
        x.color = RED;
        x.left.color = BLACK;
        x.right.color = BLACK;
    }
    
    public void put(Key key, Value value) {
        root = this.put(root, key, value);
        root.color = BLACK;
    }
    
    private Node put(Node x, Key key, Value value) {
        if(x == null) {
            return new Node(key, value, RED);
        }
        
        int cmp = x.key.compareTo(key);
        if(cmp < 0) {
            x.right = put(x.right, key, value);
        } else if(cmp > 0) {
            x.left = put(x.left, key, value);
        } else {
            x.value = value;
        }
        
        if(isRed(x.right) && !isRed(x.left)) {
            x = this.rotateLeft(x);
        }
        if(isRed(x.left) && isRed(x.left.left)) {
            x = this.rotateRight(x);
        }
        if(isRed(x.left) && isRed(x.right)) {
            this.flipColors(x);
        }
        return x;
    }
    

}

```

### 散列表
散列表是一种根据key直接访问数据的数据结构，其关键是通过散列函数来做key与存储位置的映射，以达到快速访问的目的。散列函数可以将key转换为数组索引，之后需要做的是如何处理碰撞（即不同key映射到同一个数组索引）。

- 拉链法
每个数组元素指向一个链表，在链表中保存实际的键值对。这种方法的问题在于可能存在热点数据使得链表过长，适当的时候需要做重建lian'bia

```java
package algorithm.search;

public class SeparateChainingHashST<Key, Value> {
    
    private static class Node {
        private Object key;
        private Object value;
        private Node next;
        
        public Node(Object key, Object value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    
    private int M;      // capacity
    private int N;      // num
    private Node[] st;
    
    public SeparateChainingHashST() {
        this(97);
    }
    
    public SeparateChainingHashST(int capacity) {
        this.M = capacity;
        this.N = 0;
        st = new Node[capacity];
    }
    
    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }
    
    @SuppressWarnings("unchecked")
    public Value get(Key key) {
        int i = hash(key);
        for(Node x = st[i]; x != null; x = x.next) {
            if(key.equals(x.key)) {
                return (Value)x.value;
            }
        }
        return null;
    }
    
    public void put(Key key, Value value) {
        if(N / M >= 2) {// TODO
            resize(M * 2);
        }
        
        int i = hash(key);
        for(Node x = st[i]; x != null; x = x.next) {
            if(key.equals(x.key)) {
                x.value = value;
                return;
            }
        }
        st[i] = new Node(key, value, st[i]);
        N ++;
    }
    
    public void delete(Key key) {
        int i = hash(key);
        if(st[i] == null) return;
        
        if(st[i].next == null) {
            if(key.equals(st[i].key)) {
                st[i] = null;
                N --;
            } else {
                return;
            }
        } else {
            Node x = st[i].next;
            Node pre = st[i];
            while(x != null) {
                if(key.equals(x.key)) {
                    pre.next = x.next;
                    return;
                } else {
                    x = x.next;
                    pre = pre.next;
                }
            }
            N --;
        }
        
        if(N < M) { // TODO
            resize(M / 2);
        }
    }
    
    @SuppressWarnings("unchecked")
    private void resize(int capacity) {
        SeparateChainingHashST<Key, Value> hashST = new SeparateChainingHashST<>();
        for(int i = 0; i < M; i ++) {
            for(Node x = st[i]; x != null; x = x.next) {
                hashST.put((Key)x.key, (Value)x.value);
            }
        }
        st = hashST.st;
        M = hashST.M;
    }

}

```

- 线性探测法
使用一个较大的数组，当输入发生碰撞时，（循环）向前找到一个空位存放键值对。获取的时候也是（循环）向前搜索知道遇到空或匹配才结束。这种方法必须在数组满时重新分配数组，这个操作相对比较耗时。另外，在删除元素时，会出现空位，这时需要把后面的元素重新输入数组。

```java
package algorithm.search;

public class LinearProbingHashST<Key, Value> {
    
    private int M;      // capacity
    private int N;      // num
    private Key[] keys;
    private Value[] values;
    
    public LinearProbingHashST() {
        this(30001);
    }
    
    @SuppressWarnings("unchecked")
    public LinearProbingHashST(int capacity) {
        this.M = capacity;
        this.N = 0;
        this.keys = (Key[]) new Object[capacity];
        this.values = (Value[]) new Object[capacity];
    }

    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }
    
    public Value get(Key key) {
        for(int i = hash(key); keys[i] != null; i ++) {
            if(key.equals(keys[i])) {
                return values[i];
            }
        }
        return null;
    }
    
    public void put(Key key, Value value) {
        if(N >= M / 2) {
            resize(M * 2);
        }
        
        int i = hash(key);
        while(keys[i] != null) {
            if(key.equals(keys[i])) {
                break;
            }
            i = (i + 1) % M;
        }
        keys[i] = key;
        values[i] = value;
        N ++;
    }
    
    public void delete(Key key) {
        int i = hash(key);
        while(keys[i] != null) {
            if(key.equals(keys[i])) {
                break;
            }
            i = (i + 1) % M;
        }
        if(keys[i] == null) return;
        
        keys[i] = null;
        values[i] = null;
        N --;
        
        i = (i + 1) % M;
        while(keys[i] != null) {
            Key tmpKey = keys[i];
            Value tmpValue = values[i];
            keys[i] = null;
            values[i] = null;
            N --;
            
            put(tmpKey, tmpValue);
            i = (i + 1) % M;
        }
        
        if(N > 0 && N == M / 8) {
            resize(M / 2);
        }
    }
    
    private void resize(int capacity) {
        LinearProbingHashST<Key, Value> hashST = new LinearProbingHashST<>(capacity);
        for(int i = 0; i < M; i ++) {
            if(keys[i] != null) {
                hashST.put(keys[i], values[i]);
            }
        }
        keys = hashST.keys;
        values = hashST.values;
        M = hashST.M;
    }

}

```


  [1]: http://static.zybuluo.com/yongdagan/fxm372ivgl15ury5ispqoofw/%E4%BA%8C%E5%8F%89%E6%A0%91.png
  [2]: http://static.zybuluo.com/yongdagan/ffes97wlxjutofe2n4vdg210/2-3%E6%A0%91.png
  [3]: http://static.zybuluo.com/yongdagan/ytv539mhlwx0zcr69bz2n1eq/%E4%BA%8C%E5%8F%89%E6%A0%91%20%282%29.png
  [4]: http://static.zybuluo.com/yongdagan/is5uxiizt9dqg5my7ulsd845/%E4%BA%8C%E5%8F%89%E6%A0%91%20%283%29.png
  [5]: http://static.zybuluo.com/yongdagan/mbi0h1t5q7g0oc01ctq2z9oh/%E4%BA%8C%E5%8F%89%E6%A0%91%20%284%29.png
  [6]: http://static.zybuluo.com/yongdagan/mwjnrwkwj0av73bkdzxs5l8a/%E4%BA%8C%E5%8F%89%E6%A0%91%20%286%29.png
  [7]: http://static.zybuluo.com/yongdagan/scw63dx4xnnhjsux5d0fy5bq/%E7%BA%A2%E9%BB%91%E6%A0%91%20%281%29.png
