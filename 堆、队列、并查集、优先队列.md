# 堆、队列、并查集、优先队列

### 栈
栈是一种后进先出的数据结构。栈既可以用数组实现，也可以用链表实现。栈的两个基础操作：
>- push: 将数据推入栈
>- pop: 将栈顶数据弹出

#### 数组实现
使用数组的实现只需维护一个一维数组，记录最后一个元素的位置（即长度），在此之上进行操作即可。需要注意的是，控制数组的长度（resize）。
```java
package algorithm.week2.stackAndQueue;

import java.util.Iterator;

public class ResizingArrayStack<Item> implements Stack<Item> {
    
    private Item[] a;
    private int n;
    
    @SuppressWarnings("unchecked")
    public ResizingArrayStack() {
        a = (Item[]) new Object[1];
        n = 0;
    }
    
    @SuppressWarnings("unchecked")
    private void resize(int capacity) {
        Item[] tmp = (Item[]) new Object[capacity];
        for(int i = 0; i < n; i ++) {
            tmp[i] = a[i];
        }
        a = tmp;
    }
    
    @Override
    public void push(Item item) {
        if(a.length == n) {
            resize(n * 2);
        }
        a[n ++] = item;
    }

    @Override
    public Item pop() {
        Item item = a[-- n];
        a[n] = null;
        if(n > 0 && a.length / 4 == n) {
            resize(a.length / 2);
        }
        return item;
    }

    @Override
    public boolean isEmpty() {
        return n == 0;
    }

    @Override
    public int size() {
        return n;
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {
            
            private int i = n;

            @Override
            public boolean hasNext() {
                return i > 0;
            }

            @Override
            public Item next() {
                return a[-- i];
            }
        };
    }

}

```

#### 链表实现
使用链表的实现非常优雅，只需维护表头指针，在其上做添加删除即可，只是使用的空间会略微比数组大（多了维护指针的空间，但各种操作都在常数时间，值得）。
```java
package algorithm.week2.stackAndQueue;

import java.util.Iterator;

public class LinkedStack<Item> implements Stack<Item> {
    
    private class Node {
        private Item item;
        private Node next;
    }
    
    private Node first;
    private int size;
    
    public LinkedStack() {
        first = null;
        size = 0;
    }
    
    @Override
    public void push(Item item) {
        Node old = first;
        first = new Node();
        first.item = item;
        first.next = old;
        
        size ++;
    }

    @Override
    public Item pop() {
        size --;
        Item item = first.item;
        first = first.next;
        return item;
    }

    @Override
    public boolean isEmpty() {
        return first == null;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {
            
            private Node current = first;

            @Override
            public boolean hasNext() {
                return current != null;
            }

            @Override
            public Item next() {
                Item item = current.item;
                current = current.next;
                return item;
            }
            
        };
    }

}

```

### 队列
队列是一种先进先出的数据结构。队列既可以用数组实现，也可以用链表实现。队列的两个基本操作：
>- enqueue: 在队尾插入元素
>- dequeue: 在队头弹出元素

#### 数组实现
数组实现相对麻烦，因为队列需要维护队头队尾两个下标，因此数组可能会出现较多的resize操作。
```java
package algorithm.week2.stackAndQueue;

import java.util.Iterator;

public class ResizingArrayQueue<Item> implements Queue<Item> {
    
    private Item[] a;
    private int first;
    private int last;
    private int size;
    
    @SuppressWarnings("unchecked")
    public ResizingArrayQueue() {
        a = (Item[]) new Object[1];
        first = last = -1;
        size = 0;
    }
    
    @SuppressWarnings("unchecked")
    private void resize(int capacity) {
        Item[] tmp = (Item[]) new Object[capacity];
        for(int i = first; i <= last; i ++) {
            tmp[i - first] = a[i];
        }
        first = 0;
        last = size - 1;
    }

    @Override
    public void enqueue(Item item) {
        if(a.length == last + 1) {
            resize(size * 2);
        }
        if(isEmpty()) {
            a[++ last] = item;
            first = last;
        } else {
            a[++ last] = item;
        }
        size ++;
    }

    @Override
    public Item dequeue() {
        Item item = a[first ++];
        size --;
        if(size > 0 && a.length / 4 == size) {
            resize(a.length / 2);
        }
        return item;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {
            
            private int i = first;

            @Override
            public boolean hasNext() {
                return i <= last;
            }

            @Override
            public Item next() {
                return a[i ++];
            }
        };
    }

}

```

#### 链表实现
链表实现需要维护队头队尾两个指针，但比数组实现相对简单。
```java
package algorithm.week2.stackAndQueue;

import java.util.Iterator;

public class LinkedQueue<Item> implements Queue<Item> {
    
    private class Node {
        private Item item;
        private Node next;
    }
    
    private Node first;
    private Node last;
    private int size;
    
    public LinkedQueue() {
        first = last = null;
        size = 0;
    }

    @Override
    public void enqueue(Item item) {
        Node oldLast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
           oldLast.next = last; 
        }
        size ++;
    }

    @Override
    public Item dequeue() {
        Item item = first.item;
        first = first.next;
        if (isEmpty()) {
            last = null;
        }
        
        size --;
        return item;
    }

    @Override
    public boolean isEmpty() {
        return first == null;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {
            
            private Node current = first;

            @Override
            public boolean hasNext() {
                return current != null;
            }

            @Override
            public Item next() {
                Item item = current.item;
                current = current.next;
                return item;
            }
            
        };
    }
    

}

```

### 并查集
并查集是一种树形数据结构，一般用数组来实现，用于处理不相交集合的合并和查询问题。其中，两个关键操作的时间复杂度为O(logN)：
>- connected: 判断两个节点是否在同一集合
>- union: 将两个节点相连

#### 基本思路
用数组表示每一个节点，下标表示自身，值表示父节点。初始时，每一个节点的父节点都设为它自身。当一个节点和其他节点相连时，它的值指向该节点。因此只要单纯查看任意两个节点是否在同一个根，即可判断两个节点是否相连。

#### 改进
1. 引入权重数组，记录每个节点所在树的深度。在执行union操作时，优先将深度小的树作为子树连接到其他树中，这样的好处是可以减少树的深度，从而更快地判断两个节点是否连在一起（更快到达根）；
2. 引入压缩操作。在执行查找当前节点的树根操作时，压缩遍历路径的深度，即向上回溯到的每一个节点在执行完此次操作时，都直接指向根，进一步局部降低树的深度。

```java
package algorithm.week1.unionFind;

public class QuickUnionWeightCompress {
	
	private int[] index;
	private int[] weight;
	
	public QuickUnionWeightCompress(int length) {
		index = new int[length];
		weight = new int[length];
		
		for(int i = 0; i < length; i ++) {
			index[i] = i;
			weight[i] = 1;
		}
	}
	
	private int root(int p) {
		if(index[p] == p) return p;
		index[p] = root(index[p]);
		return index[p];
	}
	
	public boolean connected(int p, int q) {
		return root(p) == root(q);
	}
	
	public void union(int p, int q) {
		int rootP = root(p);
		int rootQ = root(q);
		if(rootP == rootQ) return;
		
		if(weight[rootP] < weight[rootQ]) {
			index[rootP] = rootQ;
			weight[rootQ] += weight[rootP];
		} else {
			index[rootQ] = rootP;
			weight[rootP] += weight[rootQ];
		}
	}

}

```

### 优先队列（最大堆）
优先队列是一种每次返回队列中权重最大的元素的数据结构，一般使用最大堆实现。

#### 基本思路
最大堆是一种二叉树，对于每一个父节点，其值都不小于子节点的值。将一个普通队列构造成一个最大堆只需以下操作（swim）：
>- 依次输入每个值；
>- 对于每一个值，执行上移操作，若当前值大于父节点的值，则与父节点交换位置（交换到的新位置，其值必定不小于两个子节点，因为另一个原子节点必定不大于原来的父节点）；
>- 不断重复此操作从而到达一个合适的位置。

对于弹出权重最大值的操作，只需把堆顶元素与最后一个元素交换位置（数组长度减少，此时可看作原来的最后一个位置已经不存在即“弹出”）。对于新的堆顶元素需要执行以下操作来恢复最大堆的性质（sink）：
>- 与其子节点作比较，将较大的节点交换上来做父节点；
>- 不断重复此操作从而到达一个合适的位置。

使用数组可以较为轻易地实现最大堆，若根节点的下标为n，则两个子节点的下标分别是2n和2n+1，但需要注意数组下标从1开始。这样的好处是，当我们处于任意一个子节点，计算其父节点需要做的都是n/2。

```java
package algorithm.PriorityQueue;

import edu.princeton.cs.algs4.StdRandom;

public class MaxPQ<Key extends Comparable<Key>> {
    
    private Key[] pq;
    private int n;
    
    public MaxPQ(int capacity) {
        pq = (Key[]) new Comparable[capacity + 1];
        n = 0;
    }
    
    public MaxPQ() {
        this(1);
    }
    
    public boolean isEmpty() {
        return n == 0;
    }
    
    public Key delMax() {
        Key max = pq[1];
        exchange(1, n --);
        sink(1);
        pq[n + 1] = null;
        if(n > 0 && (pq.length - 1) / 4 == n) {
            resize(pq.length / 2);
        }
        return max;
    }
    
    private void sink(int k) {
        while(k * 2 <= n) {
            int j = k * 2;
            if(j < n && less(j, j + 1)) {
                j ++;
            }
            if(!less(k, j)) break;
            exchange(k, j);
            k = j;
        }
    }
    
    public void insert(Key x) {
        if(n + 1 == pq.length) {
            resize(pq.length * 2);
        }
        pq[++ n] = x;
        swim(n);
    }
    
    private void swim(int k) {
        while(k > 1 && less(k / 2, k)) {
            exchange(k, k /2);
            k /= 2;
        }
    }
    
    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }
    
    private void exchange(int i, int j) {
        Key tmp = pq[i];
        pq[i] = pq[j];
        pq[j] = tmp;
    }
    
    private void resize(int capacity) {
        Key[] tmp = (Key[]) new Comparable[capacity];
        for(int i = 1; i <= n; i ++) {
            tmp[i] = pq[i];
        }
        pq = tmp;
    }
    
    public static void main(String[] args) {
        int len = 15;
        MaxPQ<Integer> pq = new MaxPQ<>();
        for(int i = 0; i < len; i ++) {
            pq.insert(StdRandom.uniform(100));
        }
        for(int i = 0; i < len; i ++) {
            System.out.println(pq.delMax());
        }
    }

}

```
